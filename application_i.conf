deepdive {
  
  db.default: {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://localhost:5431/deepdive_small2"
    port: "5431"
    user: "czhang"
    password: "bB19871121"
  }

  calibration: {
    holdout_fraction: 0.5
  }

  schema.variables:{
    relations_taxonomy.is_correct: Boolean
    relations_formation.is_correct: Boolean
    relations_formationtemporal.is_correct: Boolean
    relations_formationlocation.is_correct: Boolean
    constants.is_correct : Boolean
    relations_formationtemporal_global2.is_correct: Boolean
    relations_formationtemporal_global.is_correct: Boolean
    relations_formationlocation_global.is_correct: Boolean
  }

  relations: {}

  extraction.extractors: {
  
    #load_docs.output_relation: "documents"
    #load_docs.input: "SELECT 0"
    #load_docs.udf: "../paleopaleo/udf/load_docs.py"

    load_entity_candidates.output_relation: "entities"
    load_entity_candidates.input: "SELECT 0"
    load_entity_candidates.udf: "../paleopaleo/udf/load_entity_candidates.py"
    #load_entity_candidates.dependencies: ["load_docs"]
    load_entity_candidates.output_batch_size: 10000000
    #load_entity_candidates.parallelism: 60

    load_relation_candidates3.output_relation: "relations_features_formationtemporal"
    load_relation_candidates3.input: "SELECT 0"
    load_relation_candidates3.udf: "../paleopaleo/udf/load_relation_candidates_formationtemporal.py"
    #load_relation_candidates3.dependencies: ["load_docs"]
    load_relation_candidates3.output_batch_size: 10000000

    load_relation_candidates1.output_relation: "relations_features_taxonomy"
    load_relation_candidates1.input: "SELECT 0"
    load_relation_candidates1.udf: "../paleopaleo/udf/load_relation_candidates_taxonomy.py"
    #load_relation_candidates1.dependencies: ["load_docs"]
    load_relation_candidates1.output_batch_size: 10000000

    load_relation_candidates2.output_relation: "relations_features_formation"
    load_relation_candidates2.input: "SELECT 0"
    load_relation_candidates2.udf: "../paleopaleo/udf/load_relation_candidates_formation.py"
    #load_relation_candidates2.dependencies: ["load_docs"]
    load_relation_candidates2.output_batch_size: 10000000

    load_relation_candidates4.output_relation: "relations_features_formationlocation"
    load_relation_candidates4.input: "SELECT 0"
    load_relation_candidates4.udf: "../paleopaleo/udf/load_relation_candidates_formationlocation.py"
    #load_relation_candidates4.dependencies: ["load_docs"]
    load_relation_candidates4.output_batch_size: 10000000


    load_relation_varialbe3.output_relation: "relations_formationtemporal"
    load_relation_varialbe3.input: "SELECT DISTINCT docid , type , eid1 , eid2 , entity1 , entity2 , is_correct from relations_features_formationtemporal"
    load_relation_varialbe3.udf: "../paleopaleo/udf/load_relation_candidates.py"
    load_relation_varialbe3.dependencies: ["load_relation_candidates3"]
    load_relation_varialbe3.output_batch_size: 10000000

    load_relation_varialbe1.output_relation: "relations_taxonomy"
    load_relation_varialbe1.input: "SELECT DISTINCT docid , type , eid1 , eid2 , entity1 , entity2 , is_correct from relations_features_taxonomy"
    load_relation_varialbe1.udf: "../paleopaleo/udf/load_relation_candidates.py"
    load_relation_varialbe1.dependencies: ["load_relation_candidates1"]
    load_relation_varialbe1.output_batch_size: 10000000

    load_relation_varialbe2.output_relation: "relations_formation"
    load_relation_varialbe2.input: "SELECT DISTINCT docid , type , eid1 , eid2 , entity1 , entity2 , is_correct from relations_features_formation"
    load_relation_varialbe2.udf: "../paleopaleo/udf/load_relation_candidates.py"
    load_relation_varialbe2.dependencies: ["load_relation_candidates2"]
    load_relation_varialbe2.output_batch_size: 10000000

    load_relation_varialbe4.output_relation: "relations_formationlocation"
    load_relation_varialbe4.input: "SELECT DISTINCT docid , type , eid1 , eid2 , entity1 , entity2 , is_correct from relations_features_formationlocation"
    load_relation_varialbe4.udf: "../paleopaleo/udf/load_relation_candidates.py"
    load_relation_varialbe4.dependencies: ["load_relation_candidates4"]
    load_relation_varialbe4.output_batch_size: 10000000


    global_temporal.output_relation: "relations_formationtemporal_global"
    global_temporal.input: "select distinct entity1, entity2, is_correct from relations_formationtemporal"
    global_temporal.udf: "../paleopaleo/udf/load_global_relations.py"
    global_temporal.dependencies: ["load_relation_varialbe3"]
    global_temporal.output_batch_size: 10000000

    global_temporal2.output_relation: "relations_formationtemporal_global2"
    global_temporal2.input: "select distinct entity1, entity2, is_correct from relations_formationtemporal"
    global_temporal2.udf: "../paleopaleo/udf/load_global_relations.py"
    global_temporal2.dependencies: ["load_relation_varialbe3"]
    global_temporal2.output_batch_size: 10000000

    global_location.output_relation: "relations_formationlocation_global"
    global_location.input: "select distinct entity1, entity2, is_correct from relations_formationlocation"
    global_location.udf: "../paleopaleo/udf/load_global_relations.py"
    global_location.dependencies: ["load_relation_varialbe4"]
    global_location.output_batch_size: 10000000

    ########GLOBAL INFERENCE OF TEMPORAL#########
    global_temporal_containment:{
        output_relation: "interval_containments"
        input: "select t0.entity1 as \"t0.formation\", t0.entity2 as \"t0.interval\", t1.entity2 as \"t1.interval\"from relations_formationtemporal_global t0, relations_formationtemporal_global t1 WHERE t0.entity1 = t1.entity1 and t0.entity2 <> t1.entity2"
        udf: "../paleopaleo/udf/interval_containment.py"
        dependencies: ["global_temporal"]
        output_batch_size: 10000000
    }

    global_temporal_not_that_possible:{
        output_relation: "interval_not_that_possible"
        input: "select t0.entity1 as \"t0.formation\", t0.entity2 as \"t0.interval\", t1.entity2 as \"t1.interval\"from relations_formationtemporal_global t0, relations_formationtemporal_global t1 WHERE t0.entity1 = t1.entity1 and t0.entity2 <> t1.entity2"
        udf: "../paleopaleo/udf/interval_not_that_possible.php"
        dependencies: ["global_temporal"]
        output_batch_size: 10000000
    }

  }

  inference.factors: {


    #fac_global_location_containment : {
    #
    #    input_query : "select t0.id as \"t0.id\", t0.is_correct as \"t0.is_correct\", t2.id as \"t2.id\", t2.is_correct as \"t2.is_correct\" from relations_formationlocation_global t0, location_hierarchy t1, relations_formationlocation_global t2 WHERE t0.entity2=t1.child AND t2.entity2=t1.parent;"
    #
    #    function: "!relations_formationlocation_global.t2.is_correct = Imply(relations_formationlocation_global.t0.is_correct)"
    #
    #    weight: "100"
    #
    #}


    #### deepdive_global3 ####
    #fac_global_temporal_not_that_possible1:{
    #    input_query: "select t0.id as \"t0.id\", t0.is_correct as \"t0.is_correct\", t1.id as \"t1.id\", t1.is_correct as \"t1.is_correct\" from relations_formationtemporal_global t0, relations_formationtemporal_global t1, interval_not_that_possible t2 WHERE t0.entity1=t1.entity1 AND t0.entity1=t2.formation AND t0.entity2=t2.interval1 AND t1.entity2=t2.interval2;"
    #    function: "!relations_formationtemporal_global.t1.is_correct = Imply(relations_formationtemporal_global.t0.is_correct)"
    #    weight: "100"
    #}

    #fac_global_temporal_not_that_possible2:{
    #    input_query: "select t0.id as \"t0.id\", t0.is_correct as \"t0.is_correct\", t1.id as \"t1.id\", t1.is_correct as \"t1.is_correct\", t3.id as \"t3.id\", t3.is_correct as \"t3.is_correct\"  from relations_formationtemporal_global2 t0, relations_formationtemporal_global2 t1, interval_not_that_possible t2 , constants t3 WHERE t3.constant='FALSE' AND  t0.entity1=t1.entity1 AND t0.entity1=t2.formation AND t0.entity2=t2.interval1 AND t1.entity2=t2.interval2;"
    #    function: "constants.t3.is_correct = Imply(relations_formationtemporal_global2.t1.is_correct, relations_formationtemporal_global2.t0.is_correct)"
    #    weight: "10"
    #}

    #### deepdive_global2 ####
    #fac_global_temporal_containment1:{
    #
    #    input_query: "select t0.id as \"t0.id\", t0.is_correct as \"t0.is_correct\", t1.id as \"t1.id\", t1.is_correct as \"t1.is_correct\" from relations_formationtemporal_global2 t0, relations_formationtemporal_global2 t1, interval_containments t2 WHERE t0.entity1=t1.entity1 AND t0.entity1=t2.formation AND t0.entity2=t2.child AND t1.entity2=t2.parent AND t0.entity2 <> t1.entity2;"
    #
    #    function: "!relations_formationtemporal_global2.t1.is_correct = Imply(relations_formationtemporal_global2.t0.is_correct)"
    #
    #    weight: "10"
    #}

    #fac_global_temporal_containment2:{
  # 	input_query: "select t0.id as \"t0.id\", t0.is_correct as \"t0.is_correct\", t1.id as \"t1.id\", t1.is_correct as \"t1.is_correct\", t3.id as \"t3.id\", t3.is_correct as \"t3.is_correct\" from relations_formationtemporal_global2 t0, relations_formationtemporal_global2 t1, interval_containments t2, constants t3 WHERE t3.constant='FALSE' AND t0.entity1=t1.entity1 AND t0.entity1=t2.formation AND t0.entity2=t2.child AND t1.entity2=t2.parent AND t0.entity2 <> t1.entity2;"

#	function: "constants.t3.is_correct = Imply(relations_formationtemporal_global2.t0.is_correct, relations_formationtemporal_global2.t1.is_correct)"

#	weight: "10"

 #   }

    #fac_global_temporal_containment1:{
    #    input_query: "select t0.id as \"t0.id\", t0.is_correct as \"t0.is_correct\", t1.id as \"t1.id\", t1.is_correct as \"t1.is_correct\", t3.id as \"t3.id\", t3.is_correct as \"t3.is_correct\" from relations_formationtemporal_global2 t0, relations_formationtemporal_global2 t1, interval_containments t2, constants t3 WHERE t3.constant='FALSE' AND t0.entity1=t1.entity1 AND t0.entity1=t2.formation AND t0.entity2=t2.child AND t1.entity2=t2.parent AND t0.entity2 <> t1.entity2;"

    #    function: "constants.t3.is_correct = Imply(!relations_formationtemporal_global2.t0.is_correct, relations_formationtemporal_global2.t1.is_correct)"

    #    weight: "10"

    #}

    #fac_global_temporal_containment3:{
    #    input_query: "select t0.id as \"t0.id\", t0.is_correct as \"t0.is_correct\", t1.id as \"t1.id\", t1.is_correct as \"t1.is_correct\", t3.id as \"t3.id\", t3.is_correct as \"t3.is_correct\" from relations_formationtemporal_global2 t0, relations_formationtemporal_global2 t1, interval_containments t2, constants t3 WHERE t3.constant='TRUE' AND t0.entity1=t1.entity1 AND t0.entity1=t2.formation AND t0.entity2=t2.child AND t1.entity2=t2.parent AND t0.entity2 <> t1.entity2;"

    #    function: "constants.t3.is_correct = Imply(relations_formationtemporal_global2.t0.is_correct)"

    #    weight: "-5"

    #}

    #fac_global_temporal_containment1:{
    #    input_query: "select t0.id as \"t0.id\", t0.is_correct as \"t0.is_correct\", t1.id as \"t1.id\", t1.is_correct as \"t1.is_correct\", t3.id as \"t3.id\", t3.is_correct as \"t3.is_correct\" from relations_formationtemporal_global2 t0, relations_formationtemporal_global2 t1, interval_containments t2, constants t3 WHERE t3.constant='TRUE' AND t0.entity1=t1.entity1 AND t0.entity1=t2.formation AND t0.entity2=t2.child AND t1.entity2=t2.parent AND t0.entity2 <> t1.entity2;"

    #    function: "constants.t3.is_correct = Imply(relations_formationtemporal_global2.t1.is_correct)"

    #    weight: "-5"

    #}


    #### deepdive_global ####
    fac_global_location : {
        input_query: "SELECT t0.*, t1.* from relations_formationlocation t0, relations_formationlocation_global t1 WHERE t0.entity1=t1.entity1 AND t0.entity2=t1.entity2"
        function: "relations_formationlocation_global.is_correct = Imply(relations_formationlocation.is_correct)"
        weight: "10"
    }

    fac_global_temporal2 : {
        input_query: "SELECT t0.*, t1.* from relations_formationtemporal_global t0, relations_formationtemporal_global2 t1 WHERE t0.entity1=t1.entity1 AND t0.entity2=t1.entity2"
        function: "relations_formationtemporal_global2.is_correct = Imply(relations_formationtemporal_global.is_correct)"
        #function: "relations_formationtemporal_global2.is_correct = Imply()"
	weight: "10"
    }


    fac_global_temporal1 : {
        input_query: "SELECT t0.*, t1.* from relations_formationtemporal t0, relations_formationtemporal_global t1 WHERE t0.entity1=t1.entity1 AND t0.entity2=t1.entity2"
        function: "relations_formationtemporal_global.is_correct = Imply(relations_formationtemporal.is_correct)"
        weight: "10"
    }

    fac_relations3.input_query: "select t0.features, t1.* from relations_features_formationtemporal t0, relations_formationtemporal t1 WHERE t0.docid=t1.docid AND t0.eid1=t1.eid1 AND t0.eid2=t1.eid2;"
    fac_relations3.function: "relations_formationtemporal.is_correct = Imply()"
    fac_relations3.weight: "?(relations_features_formationtemporal.features)"

    fac_relations4.input_query: "select t0.features, t1.* from relations_features_formationlocation t0, relations_formationlocation t1 WHERE t0.docid=t1.docid AND t0.eid1=t1.eid1 AND t0.eid2=t1.eid2;"
    fac_relations4.function: "relations_formationlocation.is_correct = Imply()"
    fac_relations4.weight: "?(relations_features_formationlocation.features)"

    fac_relations1.input_query: "select t0.features, t1.* from relations_features_taxonomy t0, relations_taxonomy t1 WHERE t0.docid=t1.docid AND t0.eid1=t1.eid1 AND t0.eid2=t1.eid2;"
    fac_relations1.function: "relations_taxonomy.is_correct = Imply()"
    fac_relations1.weight: "?(relations_features_taxonomy.features)"

    fac_relations2.input_query: "select t0.features, t1.* from relations_features_formation t0, relations_formation t1 WHERE t0.docid=t1.docid AND t0.eid1=t1.eid1 AND t0.eid2=t1.eid2;"
    fac_relations2.function: "relations_formation.is_correct = Imply()"
    fac_relations2.weight: "?(relations_features_formation.features)"

    #fac_relations1_bias.input_query: "select relations_taxonomy.* from relations_taxonomy"
    #fac_relations1_bias.function: "relations_taxonomy.is_correct = Imply()"
    #fac_relations1_bias.weight: "?(relations_taxonomy.type)"

    #fac_relations2_bias.input_query: "select relations_formation.* from relations_formation"
    #fac_relations2_bias.function: "relations_formation.is_correct = Imply()"
    #fac_relations2_bias.weight: "?(relations_formation.type)"

    #fac_relations3_bias.input_query: "select relations_formationtemporal.* from relations_formationtemporal"
    #fac_relations3_bias.function: "relations_formationtemporal.is_correct = Imply()"
    #fac_relations3_bias.weight: "?(relations_formationtemporal.type)"

    #fac_relations4_bias.input_query: "select relations_formationlocation.* from relations_formationlocation"
    #fac_relations4_bias.function: "relations_formationlocation.is_correct = Imply()"
    #fac_relations4_bias.weight: "?(relations_formationlocation.type)"


    hardrule_taxonomy2.input_query: "select t0.features, t1.* from relations_features_taxonomy t0, relations_taxonomy t1 WHERE t0.docid=t1.docid AND t0.eid1=t1.eid1 AND t0.eid2=t1.eid2 AND features='TAXONOMY2-[SYSTEMATIC PALEONTOLOGY SECTION HEADER TYPE 1]';"
    hardrule_taxonomy2.function: "relations_taxonomy.is_correct = Imply()"
    hardrule_taxonomy2.weight: "100"




  }

  sampler.sampler_args: "-l 100 -s 1 -i 100 -t 60 --diminish 0.95 --alpha 0.1"
  sampler.java_args = "-Xmx80g"

}






